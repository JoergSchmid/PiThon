<!DOCTYPE html>
<html lang="en">
<head>
    <style>
        .ctr {
            margin-left: auto;
            margin-right: auto;
            display: block;
            text-align: center;
        }
    </style>
    <meta charset="UTF-8">
    <title>Tic Tac Toe</title>
    <link rel="icon" type="image" href="../frontend/favicon.ico">
</head>
<body>

<canvas id="board" class="ctr" width="400" height="400" style="border: 4px solid black"></canvas>
<br>
<h3 id="result" class="ctr"></h3><br>

<div class="ctr">
    <input type="checkbox" id="ai_on" onclick="changeAI()">
    <label for="ai_on">AI On/Off</label><br>
</div>
<input type="button" id="reset" class="ctr" value="Reset" onclick="resetGame()">

<script>
    const canvas = document.getElementById("board");
    const resultBox = document.getElementById("result");
    const rect = canvas.getBoundingClientRect();
    const ctx = canvas.getContext("2d");
    const sideLength = canvas.height;
    const thirdLength =  sideLength / 3;
    const margin = thirdLength / 10;
    const colorGrid = "black";
    const colorPlayer = ["red", "blue"];
    const ai_drawDelay = 500;
    let ai_on = false;
    let board;
    let round = 0;
    let winner = 0;
    ctx.lineWidth = 4;
    resetGame();

    function placeSign(x, y) {
        /*
            board[] positions:
            0 1 2
            3 4 5
            6 7 8
            board[] value: 0 = neutral, 1/2 = player 1/2
         */
        if (result !== 0)
            return;
        let pos = x+y*3;
        if(board[pos] !== 0)
            return;
        let player = round % 2 === 0 ? 1:2
        board[pos] = player;
        result = checkBoard();
        if(player === 1) {
            drawX(x*thirdLength, y*thirdLength);
        } else if(player === 2) {
            drawO(x*thirdLength, y*thirdLength);
        }
        if(result !== 0) {
            resultBox.style.color = colorPlayer[result-1];
            resultBox.innerHTML = "Player " + result.toString() + " won!";
            return;
        } else if(round === 8) {
            resultBox.style.color = "black";
            resultBox.innerHTML = "ItÂ´s a tie!";
            return;
        } else {
            round++;
        }
        if(ai_on && round % 2 === 1) {
            ai_move();
        }
    }

    function ai_move() {
        let rand = Math.trunc(9*Math.random());
        for(let i = 0; i < 9; i++, rand = (rand+1) % 9) {
            if (board[rand] === 0) {
                placeSign(rand % 3, Math.trunc(rand / 3));
                return;
            }
        }
    }

    function changeAI() {
        ai_on = !ai_on;
    }

    function getGridPos(x, y) {
        return {
            a: Math.trunc(x/thirdLength),
            b: Math.trunc(y/thirdLength)
        };
    }

    function checkBoard() {
        //rows
        for(let i = 0; i <=6; i+=3)
            if (board[i] === board[i+1] && board[i] === board[i+2] && board[i] !== 0) {
                ctx.beginPath();
                ctx.strokeStyle = colorPlayer[board[i]-1]
                ctx.moveTo(0, (i/3)*thirdLength + 0.5*thirdLength);
                ctx.lineTo(sideLength, (i/3)*thirdLength + 0.5*thirdLength);
                ctx.stroke();
                return board[i];
            }

        //columns
        for(let i = 0; i<3; i++)
            if (board[i] === board[i + 3] && board[i] === board[i + 6] && board[i] !== 0) {
                ctx.beginPath();
                ctx.strokeStyle = colorPlayer[board[i]-1]
                ctx.moveTo(i*thirdLength + 0.5*thirdLength, 0);
                ctx.lineTo(i*thirdLength + 0.5*thirdLength, sideLength);
                ctx.stroke();
                return board[i];
            }

        //diagonals
        if(board[0] === board[4] && board[0] === board[8] && board[0] !== 0) {
            ctx.beginPath();
            ctx.strokeStyle = colorPlayer[board[0]-1]
            ctx.moveTo(0,0);
            ctx.lineTo(sideLength, sideLength);
            ctx.stroke();
            return board[0];
        }
        if(board[2] === board[4] && board[2] === board[6] && board[2] !== 0) {
            ctx.beginPath();
            ctx.strokeStyle = colorPlayer[board[2]-1]
            ctx.moveTo(0,sideLength);
            ctx.lineTo(sideLength, 0);
            ctx.stroke();
            return board[2];
        }

        return 0;
    }

    function resetGame() {
        drawGrid();
        board = [0,0,0,0,0,0,0,0,0];
        round = 0;
        result = 0;
        resultBox.innerHTML = "";
    }

    function drawGrid() {
        ctx.beginPath();
        ctx.strokeStyle = colorGrid;
        ctx.clearRect(0,0,sideLength,sideLength);
        ctx.moveTo(0, thirdLength);
        ctx.lineTo(sideLength, thirdLength);
        ctx.moveTo(0, 2 * thirdLength);
        ctx.lineTo(sideLength, 2 * thirdLength);
        ctx.moveTo(thirdLength, 0);
        ctx.lineTo(thirdLength, sideLength);
        ctx.moveTo(2 * thirdLength, 0);
        ctx.lineTo(2 * thirdLength, sideLength);
        ctx.stroke();
    }
    function drawX(x, y) {
        ctx.beginPath();
        ctx.strokeStyle = colorPlayer[0];
        ctx.moveTo(x+margin, y+margin);
        ctx.lineTo(x+thirdLength-margin, y+thirdLength-margin);
        ctx.moveTo(x+margin, y+thirdLength-margin);
        ctx.lineTo(x+thirdLength-margin, y+margin);
        ctx.stroke();
    }

    async function drawO(x, y) {
        if (ai_on && result === 0)
            await sleep();
        ctx.beginPath();
        ctx.strokeStyle = colorPlayer[1];
        ctx.arc(x+(thirdLength/2), y+(thirdLength/2), thirdLength*0.4, 0, 2*Math.PI);
        ctx.stroke();
    }

    function getMousePos(event) {
        return {
            x: event.clientX - rect.left,
            y: event.clientY - rect.top
        };
    }

    function isInside(pos, rect){
        return pos.x > 0 && pos.x < rect.width && pos.y < rect.y+rect.height && pos.y > rect.y
    }

    canvas.addEventListener('click', function(evt) {
        let mousePos = getMousePos(evt);
        if(isInside(mousePos, rect)) {
            let pos = getGridPos(mousePos.x, mousePos.y)
            placeSign(pos.a, pos.b);
        }
    })

    function sleep() {
        return new Promise(resolve => setTimeout(resolve, ai_drawDelay));
    }
</script>

</body>
</html>